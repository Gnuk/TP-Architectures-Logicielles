import java.util.Date;
import java.util.ArrayList;
import java.text.SimpleDateFormat;
import java.util.Calendar;
/**
* TP d'Architectures Logicielles Planification d'une réunion de travail
* @author Anthony REY <anthony.rey@etu.univ-savoie.fr>
* @author Yohann Berthon <yohann.berthon@etu.univ-savoie.fr>
* @since 15/04/2013
*/
public class Planification{

	private TupleSpace ts;
	private SimpleDateFormat formatter;

	/**
	* Constructeur
	*/
	public Planification(){
		this.initialize();
		
		System.out.println("Mon Planificateur");
		
		
		ArrayList<Participant> participants = new ArrayList<Participant>();
		Participant henri = new Participant("Henri");
		henri.addDateExclue("05/02/2013");
		henri.addDateExclue("04/02/2013");
		henri.addDateExclue("12/05/2013");
		henri.addDateExclue("03/07/2013");
		henri.addDateExclue("25/09/2013");
 		participants.add(henri);
		ArrayList<Date> datesHenri = henri.getDatesExclues();
		for(int i=0;i< datesHenri.size(); i++){
			System.out.println("Date Henri : " + datesHenri.get(i).toString());
		}
		
		this.ts.out("participants", participants);
		this.setIntervalle("01/02/2013", "01/10/2013");
		System.out.println("Here");
		Date dateFin = (Date) this.ts.rd("date fin");
		Date dateDebut = (Date) this.ts.rd("date debut");
		System.out.println(dateDebut.toString() + " :: " + dateFin.toString());
		System.out.println(this.isDansIntervalle("01/04/2013"));
		System.out.println(this.isDansIntervalle("01/11/2013"));
	}
	/**
	* Initialisation du constructeur
	*/
	private void initialize(){
		this.ts = new TupleSpace();
		this.formatter = new SimpleDateFormat("dd/MM/yyyy");
		this.ts.out("date debut", new Date());
		this.ts.out("date fin", new Date());
	}
	
	/**
	* Méthode isDansIntervalle
	*/
	public boolean isDansIntervalle(Date date){
		Date dateDebut = (Date) this.ts.rd("date debut");
		Date dateFin = (Date) this.ts.rd("date fin");
		if(dateDebut.before(date) && dateFin.after(date)){
			return true;
		}
		return false;
	}
	
	/**
	* Méthode isDansIntervalle
	*/
	public boolean isDansIntervalle(String stringDate){
		try{
			return this.isDansIntervalle(this.formatter.parse(stringDate));
		}
		catch(Exception e){
			System.err.println("Le format de date n'es pas respecté");
			System.exit(0);
		}
		return false;
	}
	
	/**
	* Méthode setIntervalle
	*/
	public void setIntervalle(Date debut, Date fin){
		if(debut.before(fin)){
			this.ts.add("date debut", debut);
			this.ts.add("date fin", fin);
		}
		else{
			System.err.println("Attention : La date de début n'est pas avant la date de fin");
			System.exit(0);
		}
	}
	
	/**
	* Méthode setIntervalle
	*/
	public void setIntervalle(String stringDebut, String stringFin){
		try{
			Date debut = this.formatter.parse(stringDebut);
			Date fin = this.formatter.parse(stringFin);
			this.setIntervalle(debut, fin);
		}
		catch(Exception e){
			System.err.println("Le format de date n'es pas respecté");
			System.exit(0);
		}
	}
	
	/**
	* Vérifie si 3/4 des participants sont disponibles à une date
	* @param date La date à vérifier pour les participants 
	*/
	private boolean isTroisQuartParticipants(Date date){
		ArrayList<Participant> participants = (ArrayList<Participant>) this.ts.rd("participants");
		int size = participants.size();
		int troisQuart = ((3*size) /4);
		int nbDisponibles = 0;
		for(int i = 0; i < size; i++){
			if(participants.get(i).isDispoPourDate(date)){
				nbDisponibles++;
			}
		}
		if(nbDisponibles >= troisQuart){
			return true;
		}
		return false;
	}
	
	private int compteDatePreferentielle(Date date){
		ArrayList<Participant> participants = (ArrayList<Participant>) this.ts.rd("participants");
		int cpt = 0;
		for(Participant participant: participants){
			if(participant.checkDatePreferentielle(date)){
				cpt++;
			}
		}
		return cpt;
	}
	
	private Date bestDate(){
		try{
			Date dateCourante = selectFirstDatePotable();
			Date dateFin = (Date) this.ts.rd("date fin");
			Date dateChoisie = dateCourante;
			int compte = this.compteDatePreferentielle(dateChoisie);
			while(dateCourante.before(dateFin)){
				if(this.isTroisQuartParticipants(dateCourante)){
					if(compte < this.compteDatePreferentielle(dateCourante)){
						dateChoisie = dateCourante;
						compte = this.compteDatePreferentielle(dateChoisie);
					}
				}
				dateCourante = this.addDays(dateCourante, 1);
			}
			return dateChoisie;
		}catch(Exception e){
			return null;
		}
	}
	
	private Date selectFirstDatePotable(){
		Date dateCourante = selectFirstDatePotable();
		Date dateFin = (Date) this.ts.rd("date fin");
		while(dateCourante.before(dateFin)){
			if(this.isTroisQuartParticipants(dateCourante)){
				return dateCourante;
			}
			dateCourante = this.addDays(dateCourante, 1);
		}
		return null;
	}
	
	private Date addDays(Date date, int days){
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		cal.add(Calendar.DATE, days);
		return cal.getTime();
	}
	
	
	/**
	* Méthode testTS
	*/
	public void testTS(){
		System.out.println("== Début du jeu de tests ==");
		TupleSpace tuples = new TupleSpace();
		tuples.out("42", 33);
		tuples.out("42", 42);
		System.out.println(tuples.rd("42"));
		tuples.add("42", 25);
		System.out.println(tuples.rd("42"));
		System.out.println(tuples.in("42"));
		System.out.println(tuples.in("42"));
		System.out.println(tuples.in("42"));
		System.out.println("== Fin du jeu de tests ==");
	}

	/**
	* Lancement du programme
	*/
	public static void main(String[] args){
		new Planification();
	}
}
